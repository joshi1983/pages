import { CallProcedureInstruction } from
'../../../modules/parsing/execution/instructions/CallProcedureInstruction.js';
import { Command } from
'../../../modules/parsing/Command.js';
import { compile } from
'../../../modules/parsing/compile.js';
import { InternalProcedures } from
'../../../modules/parsing/compiling/InternalProcedures.js';
import { LogoProgram } from
'../../../modules/parsing/execution/LogoProgram.js';
import { LogoParser } from
'../../../modules/parsing/LogoParser.js';
import { prefixWrapper } from
'../../helpers/prefixWrapper.js';
import { renameInternalProcedures } from
'../../../modules/parsing/compiling/renameInternalProcedures.js';
import { TestParseLogger } from
'../../helpers/TestParseLogger.js';
await Command.asyncInit();

function checkCallsToProceduresAreRenamed(instructions, logger) {
	if (!(instructions instanceof Array))
		throw new Error(`instructions must be an Array but found ${instructions}`);

	for (const instruction of instructions) {
		if (instruction instanceof CallProcedureInstruction) {
			const procName = instruction.procedure.name;
			const info = Command.getCommandInfo(procName);
			if (info === undefined && procName[0] !== '$') {
				logger(`Found a call to internal procedure ${procName} that should have a $ prefix.`);
			}
		}
	}
}

export function testCompileInternalProcedures(logger) {
	const code = InternalProcedures.getAllCode();
	const initialVariables = new Map();
	const compileOptions = {
		'forProduction': true,
		'mergeJavaScriptInstructions': true,
		'parsedOptimize': true,
		'translateToJavaScript': true,
		'forInternalProcs': true
	};
	const parseLogger = new TestParseLogger(logger, code);
	const extraProcedures = new Map();
	const proceduresMap = new Map();
	const options = {};
	const tree = LogoParser.getParseTree(code, parseLogger, proceduresMap, options);
	const program = compile(code, tree, parseLogger, extraProcedures,
		compileOptions, initialVariables);
	if (!(program instanceof LogoProgram)) {
		logger(`Expected a LogoProgram but found ${program}`);
	}
	else {
		renameInternalProcedures(program);
		// check that each and every command with commandGroup
		// internalProc group or internalProcArgCount is found in the compiled program.
		for (const info of Command.getAllCommandsInfo()) {
			if (info.commandGroup === 'internalProc' ||
			info.internalProcArgCount !== undefined) {
				const name = info.primaryName.toLowerCase();
				if (!program.procedures.has(name)) {
					logger(`Expected to find a procedure named ${name} in the internal procedures but did not.  The procedures that are implemented are: ${Array.from(program.procedures.keys()).join(', ')}`);
				}
				else if (info.internalProcArgCount !== undefined) {
					const proc = program.procedures.get(name);
					if (proc.parameters.length !== info.internalProcArgCount)
						logger(`internalProcArgCount specified as ${info.internalProcArgCount} but the parameter count for the corresponding procedure was ${proc.parameters.length}.  They should be equal.`);
				}
			}
		}
		/* Check that every procedure that has no corresponding Command
		is prefixed with '$'.
		The $ prefix is added to prevent conflicts between 
		non-command-related internal procedures
		from clashing with non-internal procedures using the same names.
		Since $ is invalid at the start of a procedure name in general,
		it is not possible to have the same name used in a user-defined procedure.

		This is a bit like how anonymous classes in Java get hashed names in
		compiled Java byte code.  It documented much but if you open a compiled .class file using an anonymous class,
		you can find the autogenerated names.
		*/
		for (const [procName, proc] of program.procedures) {
			const info = Command.getCommandInfo(procName);
			if (info === undefined && procName[0] !== '$') {
				logger('Any procedure not corresponding with a command should have its name start with $ but that is ' +
					`not the case for "${procName}"`);
			}
			checkCallsToProceduresAreRenamed(proc.instructions, prefixWrapper(`Check instructions for procedure ${procName}`, logger));
		}
		checkCallsToProceduresAreRenamed(program.instructions, prefixWrapper('global instructions', logger));
	}
};