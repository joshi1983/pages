! Communications Support Toolkit
! Version 5.0
! Copyright (c) 1997 by True BASIC, Inc.
! All Rights Reserved.
!
! This version of the Communications Support Toolkit will work only
! with Version 5.1 and later of True BASIC. It relies on the built-in
! functions comopen() and comlib(), which do most of the work. This
! module is chiefly to give call sequence compatibility with old
! versions of the toolkit.  However, the names of the subroutines
! have been changed so that they start with "COM_".

EXTERNAL

SUB Com_Open (#1, port, speed, opt$)

    ! Just need to call builtin.

    CALL ComOpen (0, #1, port, speed, opt$)

END SUB                           ! Com_Open

SUB Com_Switch(port)

    ! Just need to call builtin with method 1.

    CALL Comlib (1, port, 0, "")

END SUB                           ! Com_Switch

SUB Com_Control (opt$)

    ! Just need to call builtin with method 2.

    CALL Comlib (2, 0, 0, opt$)

END SUB                           ! Com_Control

SUB Com_Send (s$)

    ! Just need to call builtin with method  3.

    LOCAL sent

    CALL Comlib (3, sent, 0, s$)

END SUB                           ! Send

SUB Com_SendLine(s$)

    ! Need to append CR/LF and call builtin with method 3.

    LOCAL sent

    CALL Comlib (3, sent, 0, s$&chr$(13)&chr$(10))

END SUB                           ! Send_Line

SUB Com_SendCR(s$)

    ! Need to append CR and call builtin with method 3.

    LOCAL sent

    CALL Comlib (3, sent, 0, s$&chr$(13))

END SUB                           ! Send_CR

SUB Com_SendBreak

    ! Break is method 7.

    CALL Comlib (7, 0, 0, "")

END SUB                           ! Send_Break

SUB Com_Receive (buf$)

    ! Just need to call builtin with method 4.

    CALL Comlib (4, 0, 0, buf$)

END SUB                           ! Receive(buf$)

SUB Com_ReceiveLine (buf$)

    ! Scan for CR, retrieve that far.
    ! If no CR, read all and loop.

    LOCAL scan$, p, work$

    LET buf$ = ""
    LET scan$ = chr$(13)

    DO
       CALL Comlib (6, p, 0, scan$)
       IF p = -1 THEN
          CALL Comlib (4, 0, 0, work$)

       ELSE
          CALL Comlib (4, p+1, 0, work$)    ! Retrieve up to and including CR
          LET work$[p+1:p+1] = ""      ! Get rid of CR

       END IF
       LET buf$ = buf$ & work$

    LOOP UNTIL p >= 0

END SUB                           ! Receive_Line

SUB Com_WaitLine (wtime, f, buf$)

    ! Scan for CR, retrieve that far.
    ! If no CR, read all and loop.

    LOCAL scan$, p, work$, stime

    LET buf$ = ""
    LET scan$ = chr$(13)
    LET stime = time
    LET f = 1

    DO
       CALL Comlib (6, p, 0, scan$)
       IF p = -1 THEN
          CALL Comlib (4, 0, 0, work$)

       ELSE
          CALL Comlib (4, p+1, 0, work$)    ! Retrieve up to and including CR
          LET work$[p+1:p+1] = ""      ! Get rid of CR
          LET f = 0

       END IF
       LET buf$ = buf$ & work$

    LOOP UNTIL p >= 0 or time-stime >= wtime

END SUB                           ! Wait_Line

SUB Com_WaitPrompt (p$, wtime, f, buf$)

    ! Scan for CR, retrieve that far.
    ! If no CR, read all and loop.

    LOCAL scan$, p, work$, stime

    LET buf$ = ""
    LET scan$ = p$
    LET stime = time
    LET f = 1

    DO
        CALL Comlib(6,p,0,scan$)
        IF p >= 0 THEN
           CALL Comlib(4,p+len(scan$),0,work$) ! Retrieve up to and including p$
           LET f = 0

        END IF
        LET buf$ = buf$ & work$

    LOOP UNTIL p >= 0 or time-stime >= wtime
    IF p = -1 THEN CALL Comlib(4,0,0,work$)

END SUB                           ! Wait_Prompt

DEF Com_Buf (type)

    ! Call builtin and return value in result. Method 5.
    ! It is a special version of the COM_STATUS function.

    !	Type:	JJ0 Q bytes waiting to be sent
    !	JJ      1 Q free space in output buffer
    !JJ       2 Q bytes in input buffer
    !JJ       3 Q free space in input buffer.

    CALL Comlib (5, result, type, "BUF")
    LET Com_Buf = result

END DEF                           ! Com_Buf

DEF Com_Status (type$)

    ! Call builtin and return value in result.
    ! Interrogates various conditions on the status of the line.
    ! Note that this version adds a result value
    ! possibility of -1, indicating that the information
    ! requested is not available in the given
    ! operating system.

		  ! Type$: DSR, CTS, RLSD, RI, ERR, RXOFF,
		  !        SXOFF, or CR.

    CALL Comlib (5, result, 0, type$)
    LET Com_Status = result

END DEF                           ! Com_Status

! End of library
