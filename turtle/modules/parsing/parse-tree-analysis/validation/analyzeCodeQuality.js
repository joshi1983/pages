import { CachedParseTree } from '../CachedParseTree.js';
import { logAllTips } from '../tip-generators/logAllTips.js';
import { ParseLogger } from '../../loggers/ParseLogger.js';
import { ParseTreeToken } from '../../ParseTreeToken.js';
import { validateAnimationSetupProcedure } from './validateAnimationSetupProcedure.js';
import { validateAnimationSnapshotStyleProcedure } from './validateAnimationSnapshotStyleProcedure.js';
import { validateAnimationTimeUsage } from './validateAnimationTimeUsage.js';
import { validateArgumentCounts } from './validateArgumentCounts.js';
import { validateBezierCalls } from './validateBezierCalls.js';
import { validateBinaryOperatorParameters } from './validateBinaryOperatorParameters.js';
import { validateClamp } from './validateClamp.js';
import { validateClosePathUsage } from './validateClosePathUsage.js';
import { validateConsecutiveCommands } from './validateConsecutiveCommands.js';
import { validateCurvedBracketExpressions } from './validateCurvedBracketExpressions.js';
import { validateDataTypes2 } from './validateDataTypes2.js';
import { validateDistinctForLoopVariableNames } from './validateDistinctForLoopVariableNames.js';
import { validateForLoops } from './validateForLoops.js';
import { validateGradientColorStops } from './validateGradientColorStops.js';
import { validateIndependentlyUseful } from './validateIndependentlyUseful.js';
import { validateInfiniteLoops } from './validateInfiniteLoops.js';
import { validateInstructionListChildrenAllParameterizedGroups } from './validateInstructionListChildrenAllParameterizedGroups.js';
import { validateInvoke } from './validateInvoke.js';
import { validateKeywords } from './validateKeywords.js';
import { validateLinearGradients } from './validateLinearGradients.js';
import { validateListsAndExpressions } from './validateListsAndExpressions.js';
import { validateListElementTypes } from './validateListElementTypes.js';
import { validateLocalMakeNotForGlobalVariables } from './validateLocalMakeNotForGlobalVariables.js';
import { validateLongStrings } from './validateLongStrings.js';
import { validateMinLen } from './validateMinLen.js';
import { validateNumberRanges } from './validateNumberRanges.js';
import { validateOutputAndStopCalls } from './validateOutputAndStopCalls.js';
import { validateOverwrittenParameters } from './validateOverwrittenParameters.js';
import { validatePolyCommandUsage } from './validatePolyCommandUsage.js';
import { validateProcedureInProcedure } from './validateProcedureInProcedure.js';
import { validateProcedureNames } from './validateProcedureNames.js';
import { validateProcedureParametersNotNull } from './validateProcedureParametersNotNull.js';
import { validateProcedureParametersUnique } from './validateProcedureParametersUnique.js';
import { validateProcedureStartTokens } from './validateProcedureStartTokens.js';
import { validateQuotes } from './validateQuotes.js';
import { validateReadCommand } from './validateReadCommand.js';
import { validateRefTypes } from './validateRefTypes.js';
import { validateRepcountCalls } from './validateRepcountCalls.js';
import { validateStringFormats } from './validateStringFormats.js';
import { validateTypeEqualitySymbols } from './validateTypeEqualitySymbols.js';
import { validateUnaryOperatorParameters } from './validateUnaryOperatorParameters.js';
import { validateUndeclaredVariableRead } from './validateUndeclaredVariableRead.js';
import { validateUnrecognizedParameterizedGroupNames } from './validateUnrecognizedParameterizedGroupNames.js';
import { validateUnusedVariables } from './validateUnusedVariables.js';
import { validateUselessCode } from './validateUselessCode.js';
import { validateVariableNames } from './validateVariableNames.js';

export function analyzeCodeQuality(tree, parseLogger, proceduresMap, initialVariablesMap) {
	if (!(parseLogger instanceof ParseLogger))
		throw new Error('parseLogger must be a ParseLogger');
	if (!(proceduresMap instanceof Map))
		throw new Error('proceduresMap must be a Map');
	if (!(initialVariablesMap instanceof Map))
		throw new Error('initialVariablesMap must be a Map');

	const cachedParseTree = new CachedParseTree(tree, proceduresMap, initialVariablesMap);

	logAllTips(cachedParseTree, parseLogger);
	validateAnimationSetupProcedure(cachedParseTree, parseLogger);
	validateAnimationSnapshotStyleProcedure(cachedParseTree, parseLogger);
	validateAnimationTimeUsage(cachedParseTree, parseLogger);
	validateArgumentCounts(cachedParseTree, parseLogger);
	validateBezierCalls(cachedParseTree, parseLogger);
	validateBinaryOperatorParameters(cachedParseTree, parseLogger);
	validateClamp(cachedParseTree, parseLogger);
	validateClosePathUsage(cachedParseTree, parseLogger);
	validateConsecutiveCommands(cachedParseTree, parseLogger);
	validateCurvedBracketExpressions(cachedParseTree, parseLogger);
	validateDataTypes2(cachedParseTree, parseLogger);
	validateDistinctForLoopVariableNames(cachedParseTree, parseLogger);
	validateForLoops(cachedParseTree, parseLogger);
	validateGradientColorStops(cachedParseTree, parseLogger);
	validateIndependentlyUseful(cachedParseTree, parseLogger);
	validateInfiniteLoops(cachedParseTree, parseLogger);
	validateInstructionListChildrenAllParameterizedGroups(cachedParseTree, parseLogger);
	validateInvoke(cachedParseTree, parseLogger);
	validateKeywords(cachedParseTree, parseLogger);
	validateLinearGradients(cachedParseTree, parseLogger);
	validateListsAndExpressions(cachedParseTree, parseLogger);
	validateListElementTypes(cachedParseTree, parseLogger);
	validateLocalMakeNotForGlobalVariables(cachedParseTree, parseLogger);
	validateLongStrings(cachedParseTree, parseLogger);
	validateMinLen(cachedParseTree, parseLogger);
	validateNumberRanges(cachedParseTree, parseLogger);
	validateOutputAndStopCalls(cachedParseTree, parseLogger);
	validateOverwrittenParameters(cachedParseTree, parseLogger);
	validatePolyCommandUsage(cachedParseTree, parseLogger);
	validateProcedureInProcedure(cachedParseTree, parseLogger);
	validateProcedureNames(cachedParseTree, parseLogger);
	validateProcedureParametersNotNull(cachedParseTree, parseLogger);
	validateProcedureParametersUnique(cachedParseTree, parseLogger);
	validateProcedureStartTokens(cachedParseTree, parseLogger);
	validateQuotes(cachedParseTree, parseLogger);
	validateReadCommand(cachedParseTree, parseLogger);
	validateRefTypes(cachedParseTree, parseLogger);
	validateRepcountCalls(cachedParseTree, parseLogger);
	validateStringFormats(cachedParseTree, parseLogger);
	validateTypeEqualitySymbols(cachedParseTree, parseLogger);
	validateUnaryOperatorParameters(cachedParseTree, parseLogger);
	validateUndeclaredVariableRead(cachedParseTree, parseLogger);
	validateUnrecognizedParameterizedGroupNames(cachedParseTree, parseLogger);
	validateUnusedVariables(cachedParseTree, parseLogger);
	validateUselessCode(cachedParseTree, parseLogger);
	validateVariableNames(cachedParseTree, parseLogger);
};