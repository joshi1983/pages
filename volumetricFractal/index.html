<!DOCTYPE html>
<html lang="en">
	<head>
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<title>Volumetric JuliaSet Fractal Viewer</title>
		<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
		<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
		<script src="script.js"></script>
		<link rel="stylesheet" href="style.css">
	</head>
	<body>
		<div id="settings">
			<div class="row">
				<div class="col-md-4">
					<div class="labelled-input-pair">
						<label for="show-outline">Show Sphere Outline</label>
						<input id="show-outline" type="checkbox" checked>
					</div>
				</div>
				<div class="col-md-4">
					<div class="labelled-input-pair">
						<label for="sphere-radius">Sphere Radius</label>
						<input id="sphere-radius" type="range" value="1.5" step="0.01" min="0.1" max="10.0">
					</div>
				</div>
				<div class="col-md-4">
					<div class="labelled-input-pair">
						<label for="max-iterations">Max Iterations</label>
						<input id="max-iterations" type="range" value="50" step="1" min="5" max="100">
					</div>
				</div>
				<div class="col-md-6">
					<div class="labelled-input-pair">
						<label for="c-real">c Real</label>
						<input id="c-real" type="range" value="0.3" step="0.01" min="-5" max="5">
					</div>
				</div>
				<div class="col-md-6">
					<div class="labelled-input-pair">
						<label for="show-plane">Show Plane</label>
						<input type="checkbox" id="show-plane">
					</div>
				</div>
				<div class="col-sm-12">
					<div class="collapsible-row">
						<div id="wide-column" class="show-light-settings">
							<div id="cut-plane-settings">
								<div id="axis-selector">
									<label>Axis</label>
									<select id="plane-cut-axis">
										<option value="1">X</option>
										<option value="2">Y</option>
										<option value="3">Z</option>
									</select>
								</div>
								<div id="plane-cut-value-selector">
									<div class="labelled-input-pair">
										<label for="plane-cut-value">Plane Cut Value</label>
										<input type="range" id="plane-cut-value" value="0" step="0.01" min="-5" max="5">
									</div>
								</div>
							</div>
							<fieldset id="light-settings">
								<legend>Light Direction</legend>
								<div class="row">
									<div class="col-sm-4">
										<div class="labelled-input-pair">
											<label for="light-x">X</label>
											<input id="light-x" type="range" value="0" step="0.01" min="-5" max="5">
										</div>
									</div>
									<div class="col-sm-4">
										<div class="labelled-input-pair">
											<label for="light-y">Y</label>
											<input id="light-y" type="range" value="5" step="0.01" min="-5" max="5">
										</div>
									</div>
									<div class="col-sm-4">
										<div class="labelled-input-pair">
											<label for="light-z">Z</label>
											<input id="light-z" type="range" value="0" step="0.01" min="-5" max="5">
										</div>
									</div>
								</div>
							</fieldset>
						</div>
						<div class="toggler-container">
							<button id="collapse-settings-button" class="fa fa-arrow-circle-o-up"><span class="sr-only">Toggle</span></button>
						</div>
					</div>
				</div>
			</div>
		</div>
		<button id="expand-settings-button" class="fa fa-cog"><span class="sr-only">Settings</span></button>
		<canvas></canvas>

<script type='glsl/vertex'>
  attribute vec2 coords;
  
  void main(void) {
    gl_Position = vec4(coords.xy, 0.0, 1.0);
  }
</script>

<script type="glsl/fragment">
// <![CDATA[
precision mediump float;

uniform vec2 centre;
uniform vec3 position3D;
uniform vec2 viewRotation;
uniform float scale;
uniform float sphereRadius;
uniform float sphereRadiusSquared;
uniform float planeCutValue;
uniform int planeCutAxis;
uniform bool isShowingPlaneCut;
uniform bool isShowingCircumference;
uniform vec3 lightDirection;
uniform float fractalIterationDelta;
uniform float cReal;
uniform float lightObstructionDeltaRatio;

float getValue(vec3);

vec3 rotatePoint(vec3 p)
{
	return vec3(
		p.x * viewRotation.x + p.z * viewRotation.y,
		p.y,
		p.z * viewRotation.x - p.x * viewRotation.y
	);
}

float getLightObstruction(vec3 p)
{
	vec3 position = vec3(p);
	vec3 delta = vec3(lightDirection * lightObstructionDeltaRatio);
	float result = 0.01;
	float opacityDelta = 2.0 * lightObstructionDeltaRatio;
	
	for (int i = 0; i < 1000; i++)
	{
		position += delta;
		if (length(position) > sphereRadius)
			break;
		result += getValue(position) * opacityDelta;
		if (result >= 1.0)
			return 1.0;
	}
	return result;
}

float getJuliaSetValue(vec3 p)
{
	vec2 c = vec2(
		cReal,
		p.z
		);
	vec2 newP = vec2(p.x, p.y);
	float ratio = 0.0;

	for (int i = 0; i < 10000; i++)
	{
	  //remember value of previous iteration
	  //the actual iteration, the real and imaginary part are calculated
	  newP = vec2(
		newP.x * newP.x - newP.y * newP.y + c.x,
		2.0 * newP.x * newP.y + c.y
		);
	  //if the point is outside the circle with radius 2: stop
		if (dot(newP, newP) > 4.0) {
			if (ratio < 0.2)
				return ratio * 0.5;
			return ratio;
		}
		ratio += fractalIterationDelta;
		if (ratio >= 1.0)
			return ratio;
	}
}

float getValue(vec3 p)
{
	return getJuliaSetValue(p);
}

// Assumes direction is a unit-vector.
vec2 getSphereIntersectionDistances(vec3 direction)
{
	float twoA_Reciprical = 0.5;
	float b = 2.0 * dot(position3D, direction);
	float c = dot(position3D, position3D) - sphereRadiusSquared;
	float discriminant = b * b - 4.0 * c;
	if (discriminant <= 0.0) {
		return vec2(-1.0, -1.0);
	}
	else {
		discriminant = sqrt(discriminant);
		vec2 result;
		result.y = (-b + discriminant) * twoA_Reciprical;
		if (result.y < 0.0) {
			return vec2(-1.0, -1.0); // both will be negative so no point in continuing.
		}
		result.x = max(0.0, (-b - discriminant) * twoA_Reciprical);
		return result;
	}
}

vec3 getColourFromDensity(float density)
{
	if (density > 0.7) {
		return vec3(1.0, 1.0, 1.0);
	}
	else if (density > 0.1) {
		return vec3(1.0, 1.0, 1.0);
	}
	else {
		return vec3(1.0, 0.0, 0.0);
	}
}

vec3 getColourAt(vec3 direction)
{
	vec3 result;

	// Calculate min and max value for scaleI to scan volume of a sphere around (0, 0, 0).
	vec2 iScaleRange = getSphereIntersectionDistances(direction);
	if (iScaleRange.y < 0.0)
		return result;

	if (isShowingCircumference && iScaleRange.y - iScaleRange.x < 0.2 && iScaleRange.x > 0.01) {
		result = result + vec3(2.5 * (0.2 - (iScaleRange.y - iScaleRange.x)) * vec3(1.0, 0.5, 0.1));
	}

	vec3 point;
	float remainingOpacity = 1.0;
	float scaledI = iScaleRange.x;
	float delta = 0.01;
	vec3 deltaVector = direction * delta;
	float totalRatio = 0.0;

	if (isShowingCircumference && iScaleRange.y - iScaleRange.x < 0.2 && iScaleRange.x > 0.01) {
		result = result + vec3(2.5 * (0.2 - (iScaleRange.y - iScaleRange.x)) * vec3(1.0, 0.5, 0.1));
	}
	
	point = position3D + iScaleRange.x * direction;
	for (int i = 0; i < 10000; i++) {
		point += deltaVector;
		float density = getValue(point);
		if (density > 0.01) {
			float ratio = remainingOpacity * density;
			vec3 colour = ratio * (1.0 - getLightObstruction(point)) * getColourFromDensity(density);
			result += colour;
			totalRatio += ratio;
			remainingOpacity = remainingOpacity * (1.0 - density);
			if (remainingOpacity < 0.01) {
				result = result / totalRatio;
				break;
			}
		}
		scaledI += delta;
		if (scaledI >= iScaleRange.y)
			break;
	}
	if (remainingOpacity > 0.95) {
		return result;
	}
	return result * (1.0 - remainingOpacity) / totalRatio;
}

vec3 getDiscColour(vec3 direction) {
	vec3 result;

	float distanceToPlane;

	if (planeCutAxis == 1)
		distanceToPlane = (-position3D.x - planeCutValue) / direction.x;
	else if (planeCutAxis == 2)
		distanceToPlane = (-position3D.y - planeCutValue) / direction.y;
	else
		distanceToPlane = (-position3D.z - planeCutValue) / direction.z;
	
	if (distanceToPlane < 0.0)
		return result;

	vec3 intersectionPoint = position3D + direction * distanceToPlane;
	if (length(intersectionPoint) > sphereRadius)
		return result;

	float density = length(intersectionPoint) * 0.5;
	// does the range include the distance to the plane?
	density = getValue(intersectionPoint);	
	vec3 colour = getColourFromDensity(density);

	if (density > 0.7) {
		density = (density - 0.7) / 0.3;
	}
	else if (density > 0.1) {
		density *= 1.0 / 0.7;
	}
	else {
		density *= 10.0;
	}
	
	return colour * density;
}

void main(void) {
	vec2 p = gl_FragCoord.xy;
	vec3 direction = vec3((p.x - centre.x) * scale, (p.y - centre.y) * scale, 1.0);
	direction = normalize(direction);
	direction = rotatePoint(direction);
	
	vec3 c;
	if (isShowingPlaneCut)
		c = getDiscColour(direction);
	else
		c = getColourAt(direction);
	
	gl_FragColor = vec4(c.x, c.y, c.z, 1.0);
}
// ]]>
</script>
	</body>
</html>