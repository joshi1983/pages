<!DOCTYPE html>
<html lang="en">
    <!-- Written by Josh Greig around October 17, 2020 -->
	<head>
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<title>Volumetric JuliaSet Fractal Viewer</title>
		<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
		<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
		<script src="https://cdn.rawgit.com/eligrey/FileSaver.js/master/src/FileSaver.js"></script>
		<script src="script.js"></script>
		<link rel="stylesheet" href="style.css">
	</head>
	<body>
		<div id="settings">
			<div class="row">
				<div class="col-md-3">
					<div class="labelled-input-pair">
						<label for="show-outline">Show Sphere Outline</label>
						<input id="show-outline" type="checkbox" checked>
					</div>
				</div>
				<div class="col-md-5">
					<div class="labelled-input-pair">
						<label for="sphere-radius">Sphere Radius</label>
						<input id="sphere-radius" type="range" value="1.5" step="0.01" min="0.1" max="10.0">
					</div>
				</div>
				<div class="col-md-4">
					<div class="labelled-input-pair">
						<label for="max-iterations">Max Iterations</label>
						<input id="max-iterations" type="range" value="50" step="1" min="5" max="100">
					</div>
				</div>
				<div class="col-md-10">
					<div class="labelled-input-pair">
						<label for="c-real">c Real</label>
						<input id="c-real" type="range" value="0.3" step="0.001" min="-5" max="5">
					</div>
				</div>
				<div class="col-md-2">
					<div class="labelled-input-pair">
						<label for="show-plane">Show Plane</label>
						<input type="checkbox" id="show-plane">
					</div>
				</div>
				<div class="col-sm-12">
					<div class="collapsible-row">
						<div id="wide-column" class="show-light-settings">
							<div id="cut-plane-settings">
								<div id="axis-selector">
									<fieldset>
										<legend>Cut Axis</legend>
										<div class="row">
											<div class="col-4">
												<label for="plane-cut-axis-x">X</label>
												<input type="radio" id="plane-cut-axis-x" name="plane-cut-axis" value="1">
											</div>
											<div class="col-4">
												<label for="plane-cut-axis-y">Y</label>
												<input type="radio" id="plane-cut-axis-y" name="plane-cut-axis" value="2">
											</div>
											<div class="col-4">
												<label for="plane-cut-axis-z">Z</label>
												<input type="radio" id="plane-cut-axis-z" checked name="plane-cut-axis" value="3">
											</div>
										</div>
									</fieldset>
								</div>
								<div id="plane-cut-value-selector">
									<div class="labelled-input-pair">
										<label for="plane-cut-value">Plane Cut Value</label>
										<input type="range" id="plane-cut-value" value="0.3" step="0.001" min="-5" max="5">
									</div>
								</div>
							</div>
							<fieldset id="light-settings">
								<legend>Light Settings</legend>
								<div class="row">
									<div class="col-sm-4">
										<div class="labelled-input-pair">
											<label for="light-x">X</label>
											<input id="light-x" type="range" value="-0.1" step="0.001" min="-1" max="1">
										</div>
									</div>
									<div class="col-sm-4">
										<div class="labelled-input-pair">
											<label for="light-y">Y</label>
											<input id="light-y" type="range" value="1" step="0.001" min="-1" max="1">
										</div>
									</div>
									<div class="col-sm-4">
										<div class="labelled-input-pair">
											<label for="light-z">Z</label>
											<input id="light-z" type="range" value="0.12" step="0.001" min="-1" max="1">
										</div>
									</div>
									<div class="col-sm-6">
										<div class="labelled-input-pair">
											<label for="ambient">Ambient</label>
											<input id="ambient" type="range" value="0.05" step="0.001" min="0" max="1">
										</div>
									</div>
									<div class="col-sm-6">
										<div class="labelled-input-pair">
											<label for="peak-opacity">Opacity</label>
											<input id="peak-opacity" type="range" value="2.0" step="0.001" min="0.001" max="10">
										</div>
									</div>
								</div>
							</fieldset>
						</div>
						<div class="toggler-container">
							<button id="download-image" class="fa fa-download" title="Download High Quality HD image"></button>
							<button id="collapse-settings-button" class="fa fa-arrow-circle-o-up"><span class="sr-only">Toggle</span></button>
						</div>
					</div>
				</div>
			</div>
		</div>
		<button id="expand-settings-button" class="fa fa-cog"><span class="sr-only">Settings</span></button>
		<canvas></canvas>
		<div id="render-and-download-progress">
			Rendering and Downloading...
			<progress id="download-progress-bar" min="0" max="100"></progress>
		</div>

<script type="glsl/vertex">
  attribute vec2 coords;
  
  void main(void) {
    gl_Position = vec4(coords.xy, 0.0, 1.0);
  }
</script>

<script id="main-fragment-shader" type="glsl/fragment">
// <![CDATA[
precision mediump float;

uniform float ambientFactor;
uniform vec2 centre;
uniform vec2 circleRadiusRange;
uniform float cReal;
uniform float fractalIterationDelta;
uniform bool isShowingCircumference;
uniform bool isShowingPlaneCut;
uniform vec3 lightDirection;
uniform float lightObstructionDeltaRatio;
uniform float peakSampleOpacity;
uniform float opacityCutOff;
uniform int pixelSubsampling;
uniform int planeCutAxis;
uniform float planeCutValue;
uniform vec3 position3D;
uniform float scale;
uniform float sphereRadiusSquared;
uniform float sphereRadiusWithPlaneLineSquared;
uniform vec2 viewRotation;

float getValue(vec3);

vec3 rotatePoint(vec3 p)
{
	return vec3(
		p.x * viewRotation.x + p.z * viewRotation.y,
		p.y,
		p.z * viewRotation.x - p.x * viewRotation.y
	);
}

float getLightObstruction(vec3 p)
{
	vec3 position = p;
	vec3 delta = lightDirection * lightObstructionDeltaRatio;
	float result = 0.0;
	float opacityDelta = lightObstructionDeltaRatio;
	
	for (int i = 0; i < 1000; i++)
	{
		position += delta;
		if (dot(position, position) > sphereRadiusSquared)
			break;
		result += getValue(position) * opacityDelta;
		if (result >= 1.0)
			return 1.0;
	}
	return result;
}

float getJuliaSetValue(vec3 p)
{
	vec2 c = vec2(
		cReal,
		p.z
		);
	vec2 newP = vec2(p.x, p.y);
	float ratio = 0.0;

	for (int i = 0; i < 10000; i++)
	{
	  //remember value of previous iteration
	  //the actual iteration, the real and imaginary part are calculated
	  newP = vec2(
		newP.x * newP.x - newP.y * newP.y + c.x,
		2.0 * newP.x * newP.y + c.y
		);
	  //if the point is outside the circle with radius 2: stop
		if (dot(newP, newP) > 4.0) {
			return ratio;
		}
		ratio += fractalIterationDelta;
		if (ratio >= 1.0)
			return ratio;
	}
	return ratio;
}

float getValue(vec3 p)
{
	return getJuliaSetValue(p);
}

// Assumes direction is a unit-vector.
// Returns the 2 distances to intersections with the sampled sphere.
vec2 getSphereIntersectionDistances(vec3 direction)
{
	float b = 2.0 * dot(position3D, direction);
	float c = dot(position3D, position3D) - sphereRadiusSquared;
	float discriminant = b * b - 4.0 * c;
	if (discriminant <= 0.0) {
		return vec2(-1.0, -1.0);
	}
	else {
		discriminant = sqrt(discriminant);
		vec2 result;
		result.y = (-b + discriminant) * 0.5;
        // 2a would be 2 so * 0.5 is like dividing by (2*a).
		if (result.y < 0.0) {
			return vec2(-1.0, -1.0); // both will be negative so no point in continuing.
		}
		result.x = max(0.0, (-b - discriminant) * 0.5);
		return result;
	}
}

vec3 getColourFromDensity(float density)
{
	if (density > 0.95) {
		return vec3(1.0, 1.0, 1.0);
	}
	else if (density > 0.2) {
		return vec3(1.0, 1.0, 0.5);
	}
	else {
		return vec3(1.0, 0.0, 0.0);
	}
}

vec3 getColourAt(vec3 direction)
{
	vec3 result;

	// Calculate min and max value for scaleI to scan volume of a sphere around (0, 0, 0).
	vec2 iScaleRange = getSphereIntersectionDistances(direction);
	if (iScaleRange.y < 0.0)
		return result;

	vec3 point;
	float remainingOpacity = 1.0;
	float scaledI = iScaleRange.x;
	float delta = lightObstructionDeltaRatio * 0.15;
	vec3 deltaVector = direction * delta;
	float totalRatio = 0.0;

	point = position3D + iScaleRange.x * direction;
	for (int i = 0; i < 10000; i++) {
		point += deltaVector;
		float sampledValue = getValue(point);
		float density = sampledValue * peakSampleOpacity;
		if (density > opacityCutOff) {
			float ratio = remainingOpacity * density;
			vec3 colour = getColourFromDensity(sampledValue);
			if (ambientFactor > 0.01)
				colour *= (1.0 - ambientFactor * getLightObstruction(point));

			result += colour * ratio;
			totalRatio += ratio;
			remainingOpacity = remainingOpacity * (1.0 - density);
			if (remainingOpacity < opacityCutOff) {
				break;
			}
		}
		scaledI += delta;
		if (scaledI >= iScaleRange.y)
			break;
	}
	return result;
}

vec3 getDiscColour(vec3 direction) {
	vec3 result;

	float distanceToPlane;

	if (planeCutAxis == 1)
		distanceToPlane = (-position3D.x - planeCutValue) / direction.x;
	else if (planeCutAxis == 2)
		distanceToPlane = (-position3D.y - planeCutValue) / direction.y;
	else
		distanceToPlane = (-position3D.z - planeCutValue) / direction.z;
	
	if (distanceToPlane < 0.0)
		return result;

	vec3 intersectionPoint = position3D + direction * distanceToPlane;
	float lenSquared = dot(intersectionPoint, intersectionPoint);
	
	if (lenSquared > sphereRadiusWithPlaneLineSquared)
		return result;
	else if (isShowingCircumference && lenSquared > sphereRadiusSquared)
		return vec3(1.0, 1.0, 0.0);

	float density = getValue(intersectionPoint);	
	vec3 colour = getColourFromDensity(density);

	if (density > 0.7) {
		density = (density - 0.6) / 0.4;
	}
	else if (density > 0.1) {
		density *= 1.0 / 0.7;
	}
	else {
		density *= 10.0;
	}
	
	return colour * density;
}

vec3 getPixelColourFor(vec2 p) {
	float len = length(p);
	if (len > circleRadiusRange.y) {
		return vec3(0.0, 0.0, 0.0);
	}
	else if (len > circleRadiusRange.x) {
		if (isShowingCircumference)
			return vec3(1.0, 0.0, 0.0);
		else
			return vec3(0.0, 0.0, 0.0);
	}
	vec3 direction = vec3(p.x * scale, p.y * scale, 1.0);
	direction = normalize(direction);
	direction = rotatePoint(direction);
	
	if (isShowingPlaneCut)
		return getDiscColour(direction);
	else
		return getColourAt(direction);
}

void main(void) {
	vec2 p = gl_FragCoord.xy - centre;
	vec3 c;
	float len = length(p);
	if (len - 1.0 < circleRadiusRange.y) {
		if (pixelSubsampling > 1)
		{
			float delta = 1.0 / float(pixelSubsampling);
			int a = pixelSubsampling * pixelSubsampling;
			float fx = p.x, fy;

			for (int x = 0; x < 1000; x++) {
				if (x >= pixelSubsampling)
					break;

				fy = p.y;
				for (int y = 0; y < 1000; y++) {
					if (y >= pixelSubsampling)
						break;

					c += getPixelColourFor(vec2(fx, fy));
					fy += delta;
				}
				fx += delta;
			}
			c /= float(a);
		}
		else
			c = getPixelColourFor(p);
	}
	gl_FragColor = vec4(c.x, c.y, c.z, 1.0);
}
// ]]>
</script>
	</body>
</html>